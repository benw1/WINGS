#!/usr/bin/env python
"""
Contains the Input class definition

Please note that this module is private. The Input class is
available in the main ``wpipe`` namespace - use that instead.
"""
from .core import os, glob, shutil, datetime, si
from .core import ChildrenProxy
from .core import initialize_args, wpipe_to_sqlintf_connection, clean_path
from .DPOwner import DPOwner

__all__ = ['Input']


class Input(DPOwner):
    """
        Represents a pipeline's input.

        Call signatures::

            Input(pipeline, path)
            Input(keyid)
            Input(_input)

        When __new__ is called, it queries the database for an existing
        row in the `inputs` table via `sqlintf` using the given signature.
        If the row exists, it retrieves its corresponding `sqlintf.Input`
        object, otherwise it creates a new row via a new `sqlintf.Input`
        instance. This `sqlintf.Input` object is then wrapped under the
        hidden attribute `Input._input` in the new instance of this `Input`
        class generated by __new__.

        In the latter case where a new row is created, 2 directories are
        made respectively in the directories input_root and config_root of
        the pipeline, both named after the input name. With the making of
        the sub-directory in the input_root of the pipeline, the classmethod
        _copy_data is called to copy all data located in the path given to
        the constructor parameter path over to that specific sub-directory.

        All inputs are uniquely identified by their pipeline and their name,
        which latter is determined by __new__ as the tail returned by
        os.path.split(path) of the path parameter, but alternatively, the
        constructor can take as sole argument either:
         - the primary key id of the corresponding `inputs` table row
         - the `sqlintf.Input` object interfacing that table row

        After the instantiation of __new__ is completed, the __init__ method
        calls the object method _verify_raws to construct the DataProduct
        objects for all data files located in rawspath, while moving to
        confpath all files corresponding to configuration files (i.e. with a
        '.conf' extension).

        Parameters
        ----------
        pipeline : Pipeline object
            Pipeline owning this input.
        path : string
            Path to the input file or directory of files.
        keyid : int
            Primary key id of the table row.
        _input : sqlintf.Input object exposing SQL interface
            Corresponding sqlintf object interfacing the table row.

        Attributes
        ----------
        parents : Pipeline object
            Points to attribute self.pipeline.
        name : string
            Name of the input.
        input_id : int
            Primary key id of the table row.
        timestamp : datetime.datetime object
            Timestamp of last access to table row.
        rawspath : string
            Path to the input directory specific to raw data files.
        confpath : string
            Path to the input directory specific to configuration files.
        pipeline_id : int
            Primary key id of the table row of parent pipeline.
        pipeline : Pipeline object
            Pipeline object corresponding to parent pipeline.
        targets : core.ChildrenProxy object
            List of Target objects owned by the input.
        dpowner_id : int
            Points to attribute input_id.
        rawdataproducts : list of DataProduct objects
            List of DataProduct objects owned by the input corresponding
            to raw data files.
        confdataproducts : list of DataProduct objects
            List of DataProduct objects owned by the input corresponding
            to configuration files.
        logdataproducts : list of DataProduct objects
            List of DataProduct objects owned by the input corresponding
            to logging files.
        procdataproducts : list of DataProduct objects
            List of DataProduct objects owned by the input corresponding
            to processed data files.
        dataproducts : core.ChildrenProxy object
            List of DataProduct objects owned by the input.

        Notes
        -----
        An Input object requires a Pipeline object to construct: it is notably
        recommended to use the method attach_inputs of that Pipeline object
        for constructing a collection of inputs associated to the pipeline.
        Nevertheless, one can manually construct an Input object calling the
        constructor with the parent Pipeline object and the path where to find
        the data in arguments.

        >>> my_input = wp.Input(my_pipe, path_to_data)

        An input can represents multiple targets: accordingly, the Input
        object can have as many Target objects associated to it using the
        object method target. This method has the same call signature as the
        Target object constructor without specifying the input parameter: that
        is basically by providing the name of the target if different from the
        input name, in which case the method can be called without argument.

        >>> # if name_of_target != my_input.name
        >>> new_target = my_input.target(name_of_target)
        >>> # else
        >>> new_target = my_input.target()
    """
    def __new__(cls, *args, **kwargs):
        # checking if given argument is sqlintf object or existing id
        cls._input = args[0] if len(args) else None
        if not isinstance(cls._input, si.Input):
            keyid = kwargs.get('id', cls._input)
            if isinstance(keyid, int):
                cls._input = si.session.query(si.Input).filter_by(id=keyid).one()
            else:
                # gathering construction arguments
                wpargs, args, kwargs = initialize_args(args, kwargs, nargs=1)
                pipeline = kwargs.get('pipeline', wpargs.get('Pipeline', None))
                base, name = os.path.split(clean_path(kwargs.get('path', args[0])))
                # querying the database for existing row or create
                try:
                    cls._input = si.session.query(si.Input). \
                        filter_by(pipeline_id=pipeline.pipeline_id). \
                        filter_by(name=name).one()
                except si.orm.exc.NoResultFound:
                    cls._input = si.Input(name=name,
                                          rawspath=pipeline.input_root+'/'+name,
                                          confpath=pipeline.config_root+'/'+name)
                    pipeline._pipeline.inputs.append(cls._input)
                    if not os.path.isdir(cls._input.rawspath):
                        os.mkdir(cls._input.rawspath)
                    cls._copy_data(base+'/'+name)
                    if not os.path.isdir(cls._input.confpath):
                        os.mkdir(cls._input.confpath)
        # verifying if instance already exists and return
        wpipe_to_sqlintf_connection(cls, 'Input')
        return cls._inst

    def __init__(self, *args, **kwargs):
        if not hasattr(self, '_targets_proxy'):
            self._targets_proxy = ChildrenProxy(self._input, 'targets', 'Target')
        if not hasattr(self, '_dpowner'):
            self._dpowner = self._input
        super(Input, self).__init__()
        self._verify_raws()

    @classmethod
    def select(cls, **kwargs):
        """
        Returns a list of Input objects fulfilling the kwargs filter.

        Parameters
        ----------
        kwargs : dict
            Refer to :class:`sqlintf.Input` for parameters.

        Returns
        -------
        out : list of Input object
            list of objects fulfilling the kwargs filter.
        """
        cls._temp = si.session.query(si.Input).filter_by(**kwargs)
        return list(map(cls, cls._temp.all()))

    @classmethod
    def _copy_data(cls, path):
        if hasattr(cls, '_input'):
            if hasattr(cls._input, 'rawspath'):
                shutil.copy2(path, cls._input.rawspath + '/')

    def _verify_raws(self):
        for filename in glob.glob(self.rawspath+'/*'):
            if os.path.splitext(filename)[-1] == '.conf':
                self.make_config(filename)
                os.remove(filename)
            else:
                base, name = os.path.split(filename)
                self.dataproduct(filename=name, relativepath=base, group='raw')

    @property
    def parents(self):
        """
        :obj:`Pipeline`: Points to attribute self.pipeline.
        """
        return self.pipeline

    @property
    def name(self):
        """
        str: Name of the input.
        """
        si.session.commit()
        return self._input.name

    @name.setter
    def name(self, name):
        self._input.name = name
        self._input.timestamp = datetime.datetime.utcnow()
        si.session.commit()

    @property
    def input_id(self):
        """
        int: Primary key id of the table row.
        """
        return self._input.id

    @property
    def rawspath(self):
        """
        str: Path to the input directory specific to raw data files.
        """
        return self._input.rawspath

    @property
    def confpath(self):
        """
        str: Path to the input directory specific to configuration files.
        """
        return self._input.confpath

    @property
    def pipeline_id(self):
        """
        int: Primary key id of the table row of parent pipeline.
        """
        return self._input.pipeline_id

    @property
    def pipeline(self):
        """
        :obj:`Pipeline`: Pipeline object corresponding to parent pipeline.
        """
        if hasattr(self._input.pipeline, '_wpipe_object'):
            return self._input.pipeline._wpipe_object
        else:
            from .Pipeline import Pipeline
            return Pipeline(self._input.pipeline)

    @property
    def targets(self):
        """
        :obj:`core.ChildrenProxy`: List of Target objects owned by the input.
        """
        return self._targets_proxy

    def target(self, *args, **kwargs):
        from .Target import Target
        return Target(self, *args, **kwargs)

    def make_config(self, config_file):
        config_file = clean_path(config_file)
        if config_file is not None:
            shutil.copy2(config_file, self.confpath)
            self.dataproduct(filename=os.path.split(config_file)[-1], relativepath=self.confpath, group='conf')
